{"name":"Flea-db","tagline":"A java library for creating standalone, portable, schema-full object databases supporting pagination and faceted search, and offering strong-typed and generic APIs. Built on top of Apache Lucene.","body":"#org.brutusin:flea-db [![Build Status](https://api.travis-ci.org/brutusin/flea-db.svg?branch=master)](https://travis-ci.org/brutusin/flea-db) [![Maven Central Latest Version](https://maven-badges.herokuapp.com/maven-central/org.brutusin/flea-db/badge.svg)](https://maven-badges.herokuapp.com/maven-central/org.brutusin/flea-db/) \r\n\r\nA java library for creating standalone, portable, schema-full object databases supporting [pagination](http://en.wikipedia.org/wiki/Pagination#Pagination_in_web_content) and [faceted search](http://en.wikipedia.org/wiki/Faceted_search), and offering strong-typed and generic APIs.\r\n\r\nBuilt on top of [Apache Lucene](http://lucene.apache.org/core/).\r\n\r\n**Main features:**\r\n* Schema-full/self-descriptive\r\n* Simple and powerful API. Strong-typed and generic flavors\r\n* High robustness. Record, field names and type validation.\r\n* Pagination\r\n* Faceted search\r\n* In memory and persistent versions\r\n\r\n**Table of Contents:** \r\n\r\n- [org.brutusin:flea-db](#)\r\n  - [Motivation](#motivation)\r\n  - [Maven dependency](#maven-dependency)\r\n  - [APIs](#apis)\r\n    - [GenericFleaDB](#genericfleadb)\r\n    - [ObjectFleaDB](#objectfleadb)\r\n  - [Schema](#schema)\r\n    - [JSON SPI](#json-spi)\r\n    - [JSON Schema extension](#json-schema-extension)\r\n    - [Annotations](#annotations)\r\n    - [Indexed fields nomenclature](#indexed-fields-nomenclature)\r\n    - [Indexation values](#indexation-values)\r\n  - [Usage](#usage)\r\n    - [Database persistence](#database-persistence)\r\n    - [Write operations](#write-operations)\r\n      - [Store](#store)\r\n      - [Delete](#delete)\r\n      - [Commit](#commit)\r\n      - [Optimization](#optimization)\r\n    - [Read operations](#read-operations)\r\n      - [Record queries](#record-queries)\r\n      - [Facet queries](#facet-queries)\r\n    - [Closing](#closing)\r\n  - [Index structure](#index-structure)\r\n  - [ACID properties](#acid-properties)\r\n  - [Examples](#examples)\r\n  - [Main stack](#main-stack)\r\n  - [Lucene version](#lucene-version)\r\n  - [Support, bugs and requests](#support-bugs-and-requests)\r\n  - [Authors](#authors)\r\n  - [License](#license)\r\n\r\n##Motivation\r\n* Create a library with a very simple API, self-descriptive with high robustness aimed at indexing objects and providing advanced search capabilities, pagination and faceted search. \r\n* Originally born with the purpose of indexing raw data files, and (almost) steady data sets.\r\n* *Lucene* is an extense and powerful low level library, but its API is not very easy to understand.\r\n* Putting schemas into play, self-description can be used to simplify API (fields type), to provide strong validation mechanisms, and to enable the creation of flexible and generic downstream components.\r\n* *Lucene* has a lot of experimental APIs that may (and use to) change in time. This library adds a level of indirection. providing a stable high level interface. Upgrades in the underlying *Lucene* version are absorved by *flea-db*.\r\n\r\n##Maven dependency \r\n```xml\r\n<dependency>\r\n    <groupId>org.brutusin</groupId>\r\n    <artifactId>flea-db</artifactId>\r\n</dependency>\r\n```\r\nClick [here](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.brutusin%22%20a%3A%22flea-db%22) to see the latest available version released to the Maven Central Repository.\r\n\r\nIf you are not using maven and need help you can ask [here](https://github.com/brutusin/flea-db/issues).\r\n\r\n##APIs\r\nAll `flea-db` functionality is defined by [`FleaDB`](src/main/java/org/brutusin/fleadb/FleaDB.java) interface. \r\n\r\nThe library provides two implementations for it:\r\n\r\n1. A low-level generic implementation [`GenericFleaDB`](src/main/java/org/brutusin/fleadb/impl/GenericFleaDB.java).\r\n2. A high-level strong-typed implementation [`ObjectFleaDB`](src/main/java/org/brutusin/fleadb/impl/ObjectFleaDB.java) built on top of the previous one.\r\n\r\n###GenericFleaDB\r\n[`GenericFleaDB`](src/main/java/org/brutusin/fleadb/impl/GenericFleaDB.java) is the lowest level *flea-db* implementation that defines the database schema using a JSON schema and stores and indexes records of type [`JsonNode`](https://github.com/brutusin/json/tree/master/src/main/java/org/brutusin/json/spi/JsonNode.java). It uses *Apache Lucene* APIs and [`org.brutusin:json` SPI](https://github.com/brutusin/json) to maintain two different indexes (one for the terms and other for the taxonomy, see [index structure](#index-structure)), hyding the underlying complexity from the user perspective.\r\n\r\nThis is how it works:\r\n* **On instantiation**: A [`JsonSchema`](https://github.com/brutusin/json/tree/master/src/main/java/org/brutusin/json/spi/JsonSchema.java) and an index folder are passed depending on whether the database is new and/or persistent. Then the JSON schema (passed or readed from the existing database `flea.json` descriptor file) is processed, looking for its [`index`](#json-schema-extension) properties, and finally a database [schema](src/main/java/org/brutusin/fleadb/Schema.java) is created.\r\n* **On storing**: The passed `JsonNode` record is validated against the JSON schema. Then a [`JsonTransformer`](src/main/java/org/brutusin/fleadb/impl/JsonTransformer.java) instance (making use of the processed database schema) transforms the records in terms understandable by *Lucene* (*documents*, *fields*, *facet fields* ...) and finally the storage is delegated to the *Lucene* API.\r\n* **On commit**: Underlying index and taxonomy writters are commited and searchers are refreshed to reflect the changes.\r\n* **On querying**: The [`Query`](src/main/java/org/brutusin/fleadb/query) and [`Sort`](src/main/java/org/brutusin/fleadb/sort/Sort.java) objects are transformed into terms understandable by *Lucene* making use of the database schema. The returned [paginator](src/main/java/org/brutusin/fleadb/pagination) is basically a wrapper around the underlying luecene `IndexSearcher` and `Query` objects that lazily (on demand) performs searches to the index.\r\n\r\n###ObjectFleaDB\r\n[`ObjectFleaDB`](src/main/java/org/brutusin/fleadb/impl/ObjectFleaDB.java) is built on top of `GenericFleaDB`.\r\n\r\nBasically an `ObjectFleaDB` delegates all its functionality to a wrapped `GenericFleaDB` instance, making use of `org.brutusin:json` to perform transformations `POJO<->JsonNode` and `Class<->JsonSchema`. This is the reason why all `flea-db` databases can be used with `GenericFleaDB`.\r\n\r\n## Schema\r\n###JSON SPI\r\nAs cited before, this library makes use of the [`org.brutusin:json`](https://github.com/brutusin/json), so a JSON service provider like [`json-provider`](https://github.com/brutusin/json-provider) is needed at runtime. The choosen provider will determine JSON serialization, validation, parsing, schema generation and expression semantics.\r\n\r\n###JSON Schema extension\r\nStandard JSON schema specification has been extended to declare indexable properties (`\"index\":\"index\"` and `\"index\":\"facet\"` options). See [annotations section](#annotations) for more details.\r\n\r\nExample:\r\n```json\r\n{\r\n  \"type\": \"object\",\r\n  \"properties\": {\r\n    \"age\": {\r\n      \"type\": \"integer\",\r\n      \"index\": \"index\"\r\n    },\r\n    \"category\": {\r\n      \"type\": \"string\",\r\n      \"index\": \"facet\"\r\n    }\r\n  }\r\n}\r\n```\r\n* `\"index\":\"index\"`: Means that the property is indexed by *Lucene* under a field with name set according to the rules explained in [nomenclature section](#indexed-fields-nomenclature).\r\n* `\"index\":\"facet\"`: Means that the property is indexed as in the previous case, but also a facet is created with this field name.\r\n\r\n###Annotations\r\nSee [documentation in JSON SPI](https://github.com/brutusin/json/tree/master/src/main/java/org/brutusin/json/annotations) for supported annotations used in the strong-typed scenario.\r\n\r\n###Indexed fields nomenclature\r\nDatabases are self descriptive, they provide information of their schema and indexed fields (via [`Schema`](src/main/java/org/brutusin/fleadb/Schema.java)). \r\n\r\nField semantics are inherited from the expression semantics defined in the [`org.brutusin:json-provider`](https://github.com/brutusin/json-provider/blob/master/README.md#expression-dsl)\r\n\r\n### Indexation values\r\nSupose `JsonNode node` to be stored and let `fieldId` be the expression identifying a database field, according to the previous section. \r\n\r\n```java\r\nExpression exp = JsonCodec.getInstance().compile(fieldId);\r\nJsonSchema fieldSchema = exp.projectSchema(rootSchema);\r\nJsonNode fieldNode = exp.projectNode(node);\r\n```\r\n\r\nThen, the following rules apply to extract index and facet values for that field:\r\n\r\n|fieldSchema| index:index | index:facet\r\n|--------|-------------|------------\r\n|String|`fieldNode.asString()`|`fieldNode.asString()`\r\n|Boolean|`fieldNode.asString()`|`fieldNode.asString()`\r\n|Integer|`fieldNode.asLong()`| Unsupported\r\n|Number|`fieldNode.asDouble()`|Unsupported\r\n|Object|each of its property names|each of its property names\r\n|Array|recurse for each of its elements|recurse for each of its elements\r\n\r\n##Usage\r\n### Database persistence\r\nDatabases can be created in RAM memory or in disk, depending on the addressed problem characteristics (performance, dataset size, indexation time ...).\r\n\r\nIn order to create a persistent database, a constructor(s) with a `File` argument has to be choosen:\r\n```java\r\nFlea db1 = new GenericFleaDB(indexFolder, jsonSchema);\r\n// or\r\nFlea db2 = new ObjectFleaDB(indexFolder, Record.class);\r\n```\r\n>NOTE: Multiple instances can be used to read the same persistent database (for example different concurrent JVM executions), but only one can hold the writing file-lock (claimed the first time a write method is called).\r\n\r\nOn the other side, the database will be kept in RAM memory and lost at the end of the JVM execution.\r\n```java\r\nFlea db1 = new GenericFleaDB(jsonSchema);\r\n// or\r\nFlea db2 = new ObjectFleaDB(Record.class);\r\n```\r\n\r\n### Write operations\r\nThe following operations perform modifications on the database.\r\n#### Store\r\nIn order to store a record the `store(...)` method has to be used:\r\n```java \r\ndb1.store(jsonNode);\r\n// or\r\ndb2.store(record);\r\n```\r\ninternally this ends up calling `addDocument` in the underlying *Lucene* `IndexWriter`.\r\n#### Delete\r\nThe API enables to delete a set of records using `delete(Query q)`.\r\n>NOTE: Due to Lucene facet internals, categories are never deleted from the taxonomy index, despite of being orphan.\r\n\r\n#### Commit\r\nPrevious operations (store and delete) are not (and won't ever be) visible until `commit()` is called. Underlying seachers and writers are released, to be lazily created in further read or write operations.\r\n\r\n#### Optimization\r\nDatabases can be optimized in order to achieve a better performance by using `optimize()`. This method triggers a highly costly (in terms of free disk space needs and computation) merging of the *Lucene* index segments into a single one. \r\n\r\nNevertheless, this operation is useful for immutable databases, that can be once optimized prior its usage.\r\n\r\n### Read operations\r\nTwo kind of read operations can be performed, both supporting a [Query](src/main/java/org/brutusin/fleadb/query) argument, that defines the search criteria.\r\n\r\n#### Record queries\r\nRecord queries can be [paginated](http://en.wikipedia.org/wiki/Pagination#Pagination_in_web_content) and the ordering of the results can be specified via a [Sort](src/main/java/org/brutusin/fleadb/sort/Sort.java) argument.\r\n\r\n* `public E getSingleResult(final Query q)`\r\n* `public Paginator<E> query(final Query q)`\r\n* `public Paginator<E> query(final Query q, final Sort sort)`\r\n\r\n#### Facet queries\r\n[`FacetResponse`](src/main/java/org/brutusin/fleadb/facet/FacetResponse.java) represents the faceting info returned by the database.\r\n\r\n* `public List<FacetResponse> getFacetValues(final Query q, FacetMultiplicities activeFacets)`\r\n* `public List<FacetResponse> getFacetValues(final Query q, int maxFacetValues)`\r\n* `public List<FacetResponse> getFacetValuesStartingWith(String facetName, String prefix, Query q, int max)`\r\n* `public int getNumFacetValues(Query q, String facetName)`\r\n* `public double getFacetValueMultiplicity(String facetName, String facetValue, Query q)`\r\n\r\nFaceting is provided by [lucene-facet](http://lucene.apache.org/core/4_10_3/facet/index.html).\r\n\r\n### Closing\r\nDatabases must be closed after its usage, via `close()` method in order to free the resources and locks hold. Closing a database makes it no longer usable.\r\n\r\n##Threading issues\r\nBoth implementations are thread safe and can be shared across multiple threads.\r\n\r\n##Index structure\r\nPersistent *flea-db* databases create the following index structure: \r\n```\r\n/flea-db/\r\n|-- flea.json\r\n|-- record-index\r\n|   |-- ...\r\n|-- taxonomy-index\r\n|   |-- ...\r\n```\r\nbeing `flea.json` the database descriptor containing its schema, and being `record-index` and `taxonomy-index` subfolders the underlying *Lucene* index structures.\r\n\r\n##ACID properties\r\n`flea-db` offers the following [ACID](http://en.wikipedia.org/wiki/ACID) properties, inherited from *Lucene* ones:\r\n\r\n* **Atomicity:** When changes are performed, and then committed, either all (if the commit succeeds) or none (if the commit fails) of them will be visible.\r\n* **Consistency:** if the computer or OS crashes, or the JVM crashes or is killed, or power is lost, indexes will remain intact (ie, not corrupt).\r\n* **Isolation:** Changes performed are not visible until committed. \r\n* **Durability:** In case of a persistent database, when the commit returns, all changes have been written to disk. If the JVM crashes, all changes will still be present in the index, despite of not the database not being properly closed.\r\n\r\n##Examples:\r\n**Generic API:**\r\n```java \r\n// Generic interaction with a previously created database\r\nFleaDB<JsonNode> db = new GenericFleaDB(indexFolder);\r\n\r\n// Store records\r\nJsonNode json = JsonCodec.getInstance.parse(\"...\");\r\ndb.store(json);\r\ndb.commit();\r\n\r\n// Query records\r\nQuery q = Query.createTermQuery(\"$.id\", \"0\");\r\nPaginator<JsonRecord> paginator = db.query(q);\r\nint totalPages = paginator.getTotalPages(pageSize);\r\nfor (int i = 1; i <= totalPages; i++) {\r\n    List<JsonRecord> page = paginator.getPage(i, pageSize);\r\n    for (int j = 0; j < page.size(); j++) {\r\n        JsonRecord json = page.get(j);\r\n        System.out.println(json);\r\n    }\r\n}\r\ndb.close();\r\n```\r\n\r\n**Strong-typed API:**  \r\n```java \r\n// Create object database\r\nFleaDB<Record> db = new ObjectFleaDB(indexFolder, Record.class);\r\n\r\n// Store records\r\nfor (int i = 0; i < REC_NO; i++) {\r\n    Record r = new Record();\r\n    // ... populate record\r\n    db.store(r);\r\n}\r\ndb.commit();\r\n\r\n// Query records\r\nQuery q = Query.createTermQuery(\"$.id\", \"0\");\r\nPaginator<Record> paginator = db.query(q);\r\nint totalPages = paginator.getTotalPages(pageSize);\r\nfor (int i = 1; i <= totalPages; i++) {\r\n    List<Record> page = paginator.getPage(i, pageSize);\r\n    for (int j = 0; j < page.size(); j++) {\r\n        Record r = page.get(j);\r\n        System.out.println(r);\r\n    }\r\n}\r\ndb.close();\r\n``` \r\n\r\nSee available [test classes](src/test/java/org/brutusin/fleadb/impl/) for more examples.\r\n\r\n##Main stack\r\nThis module could not be possible without:\r\n* [Apache Lucene](http://lucene.apache.org/core/).\r\n* The following [json-codec-jackson](https://github.com/brutusin/json-codec-jackson) dependencies:\r\n  * [FasterXML/jackson stack](https://github.com/FasterXML/jackson): The underlying JSON stack.\r\n  * [com.fasterxml.jackson.module:jackson-module-jsonSchema](https://github.com/FasterXML/jackson-module-jsonSchema): For java class to JSON schema mapping.\r\n  * [com.github.fge:json-schema-validator](https://github.com/fge/json-schema-validator): For validation against a JSON schema.\r\n\r\n##Lucene version\r\n`4.10.3` (Dec, 2014)\r\n\r\n## Support, bugs and requests\r\nhttps://github.com/brutusin/flea-db/issues\r\n\r\n## Authors\r\n\r\n- Ignacio del Valle Alles (<https://github.com/idelvall/>)\r\n\r\nContributions are always welcome and greatly appreciated!\r\n\r\n##License\r\nApache License, Version 2.0\r\nhttp://www.apache.org/licenses/LICENSE-2.0\r\n","google":"UA-69662024-1","note":"Don't delete this file! It's used internally to help with page regeneration."}